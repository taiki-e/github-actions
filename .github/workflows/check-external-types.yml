# Run `cargo check-external-types` in a way that respects the docs.rs metadata.
#
# There is no stability guarantee for this workflow, since it's supposed to only be
# used in infra managed by us.
#
# Note: We also call this workflow from tidy.yml.
#
# Usage:
#
# ```yml
#   check-external-types:
#     uses: taiki-e/github-actions/.github/workflows/check-external-types.yml@main
# ```
#
# See "on.workflow_call.inputs" below for input options.

permissions:
  contents: read

on:
  workflow_call:
    inputs:
      rust:
        required: false
        type: string
        default: nightly-2025-08-06
      target:
        required: false
        type: string
      args:
        required: false
        type: string

env:
  CARGO_INCREMENTAL: 0
  CARGO_NET_GIT_FETCH_WITH_CLI: true
  CARGO_NET_RETRY: 10
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  RUSTFLAGS: -D warnings
  RUSTDOCFLAGS: -D warnings
  RUSTUP_MAX_RETRIES: 10
  # Reusable workflows cannot inherit environment variables.
  ATOMIC_MAYBE_UNINIT_DENY_WARNINGS: 1
  CARGO_HACK_DENY_WARNINGS: 1
  CARGO_LLVM_COV_DENY_WARNINGS: 1
  CARGO_MINIMAL_VERSIONS_DENY_WARNINGS: 1
  CARGO_NO_DEV_DEPS_DENY_WARNINGS: 1
  CONST_FN_DENY_WARNINGS: 1
  PORTABLE_ATOMIC_DENY_WARNINGS: 1
  SEMIHOSTING_DENY_WARNINGS: 1

defaults:
  run:
    shell: bash --noprofile --norc -CeEuo pipefail {0}

jobs:
  check-external-types:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - uses: taiki-e/checkout-action@v1
      - uses: taiki-e/github-actions/install-rust@main
        with:
          toolchain: ${{ inputs.rust }}
      - uses: taiki-e/cache-cargo-install-action@v2
        with:
          tool: cargo-check-external-types@0.3.0
      # Refs:
      # - https://github.com/rust-lang/docs.rs/blob/HEAD/crates/metadata/lib.rs
      # - https://github.com/rust-lang/docs.rs/blob/HEAD/src/docbuilder/rustwide_builder.rs
      # - https://github.com/awslabs/cargo-check-external-types
      # NB: sync with docs.yml
      - name: Run cargo check-external-types
        run: |
          IFS=$'\n\t'
          trap -- 's=$?; printf >&2 "%s\n" "${0##*/}:${LINENO}: \`${BASH_COMMAND}\` exit with ${s}"; exit ${s}' ERR
          retry() {
            for i in {1..10}; do
              if "$@"; then
                return 0
              else
                sleep "${i}"
              fi
            done
            "$@"
          }
          normalize_comma_or_space_separated() {
            # Normalize whitespace characters into space because it's hard to handle single input contains lines with POSIX sed alone.
            local list="${1//[$'\r\n\t']/ }"
            if [[ "${list}" == *","* ]]; then
              # If a comma is contained, consider it is a comma-separated list.
              # Drop leading and trailing whitespaces in each element.
              sed -E 's/ *, */,/g; s/^.//' <<<",${list},"
            else
              # Otherwise, consider it is a whitespace-separated list.
              # Convert whitespace characters into comma.
              sed -E 's/ +/,/g; s/^.//' <<<" ${list} "
            fi
          }
          base_args=()
          if [[ -n "${INPUT_ARGS}" ]]; then
            while read -rd' '; do
              [[ -z "${REPLY}" ]] || base_args+=("${REPLY}")
            done <<<"${INPUT_ARGS//[$'\r\n\t']/ } " # Normalize whitespace characters into space.
          fi
          metadata=$(cargo metadata --format-version=1 --no-deps)
          # Handle target inputs.
          base_targets=()
          if [[ -n "${INPUT_TARGET}" ]]; then
            while read -rd,; do
              base_targets+=(--target="${REPLY}")
              retry rustup target add "${REPLY}" || true # tier 3 targets fail to install rustup target
            done < <(normalize_comma_or_space_separated "${INPUT_TARGET}")
          fi
          # Run cargo check-external-types for public crates with features specified in docs.rs metadata in Cargo.toml.
          # Publishing is unrestricted if null, and forbidden if an empty array.
          for pkg in $(jq -c '. as $metadata | .workspace_members[] as $id | $metadata.packages[] | select(.id == $id and .publish != [] and .targets[].kind[] == "lib")' <<<"${metadata}"); do
            args=("${base_args[@]}")
            eval "$(jq -r '@sh "MANIFEST_PATH=\(.manifest_path)"' <<<"${pkg}")"
            args+=(--manifest-path "${MANIFEST_PATH}")
            docs_rs_metadata=$(jq '.metadata.docs.rs' <<<"${pkg}")
            if [[ "${docs_rs_metadata}" == "null" ]]; then
              docs_rs_metadata=$(jq '.metadata."docs.rs"' <<<"${pkg}")
              if [[ "${docs_rs_metadata}" == "null" ]]; then
                docs_rs_metadata='{}'
              fi
            fi
            pkg_targets=()
            # Respect target-related fields specified in docs.rs metadata if inputs.target is empty.
            if [[ -z "${INPUT_TARGET}" ]]; then
              default_target=$(jq -r '."default-target"' <<<"${docs_rs_metadata}")
              if [[ "${default_target}" != null ]]; then
                pkg_targets+=(--target="${default_target}")
                retry rustup target add "${default_target}" || true # tier 3 targets fail to install rustup target
              fi
              if [[ "$(jq '.targets' <<<"${docs_rs_metadata}")" != null ]]; then
                for target in $(jq -r '.targets[]' <<<"${docs_rs_metadata}"); do
                  pkg_targets+=(--target="${target}")
                  retry rustup target add "${target}" || true # tier 3 targets fail to install rustup target
                done
              fi
            else
              pkg_targets+=("${base_targets[@]}")
            fi
            if [[ "$(jq '.features' <<<"${docs_rs_metadata}")" != null ]]; then
              for feature in $(jq -r '.features[]' <<<"${docs_rs_metadata}"); do
                args+=(--features "${feature}")
              done
            fi
            if [[ "$(jq '."all-features"' <<<"${docs_rs_metadata}")" == 'true' ]]; then
              args+=(--all-features)
            fi
            if [[ "$(jq '."no-default-features"' <<<"${docs_rs_metadata}")" == 'true' ]]; then
              args+=(--no-default-features)
            fi
            if [[ ${#pkg_targets[@]} -gt 0 ]]; then
              # sort and dedup
              IFS=$'\n'
              # shellcheck disable=SC2207
              pkg_targets=($(LC_ALL=C sort -u <<<"${pkg_targets[*]}"))
              IFS=$'\n\t'
              for target in "${pkg_targets[@]}"; do
                (
                  set -x
                  cargo check-external-types "${args[@]}" "${target}"
                )
              done
            else
              (
                set -x
                cargo check-external-types "${args[@]}"
              )
            fi
          done
        env:
          INPUT_ARGS: ${{ inputs.args }}
          INPUT_TARGET: ${{ inputs.target }}
