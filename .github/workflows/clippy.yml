# Run `cargo clippy` and apply clippy for doctest.
#
# There is no stability guarantee for this workflow, since it's supposed to only be
# used in infra managed by us.
#
# Note: We also call this workflow from tidy.yml.
#
# Usage:
#
# ```yml
#   docs:
#     uses: taiki-e/github-actions/.github/workflows/clippy.yml@main
# ```
#
# See "on.workflow_call.inputs" below for input options.

permissions:
  contents: read

on:
  workflow_call:
    inputs:
      rust:
        required: false
        type: string
        default: nightly
      target:
        required: false
        type: string
      args:
        required: false
        type: string

env:
  CARGO_INCREMENTAL: 0
  CARGO_NET_GIT_FETCH_WITH_CLI: true
  CARGO_NET_RETRY: 10
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  RUSTFLAGS: -D warnings
  RUSTDOCFLAGS: -D warnings
  RUSTUP_MAX_RETRIES: 10
  # Reusable workflows cannot inherit environment variables.
  ATOMIC_MAYBE_UNINIT_DENY_WARNINGS: 1
  CARGO_HACK_DENY_WARNINGS: 1
  CARGO_LLVM_COV_DENY_WARNINGS: 1
  CARGO_MINIMAL_VERSIONS_DENY_WARNINGS: 1
  CARGO_NO_DEV_DEPS_DENY_WARNINGS: 1
  CONST_FN_DENY_WARNINGS: 1
  PORTABLE_ATOMIC_DENY_WARNINGS: 1
  SEMIHOSTING_DENY_WARNINGS: 1

defaults:
  run:
    shell: bash --noprofile --norc -CeEuo pipefail {0}

jobs:
  clippy:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - uses: taiki-e/checkout-action@v1
      - uses: taiki-e/github-actions/install-rust@main
        with:
          toolchain: ${{ inputs.rust }}
          component: clippy
      - name: Run cargo clippy
        run: |
          IFS=$'\n\t'
          trap -- 's=$?; printf >&2 "%s\n" "${0##*/}:${LINENO}: \`${BASH_COMMAND}\` exit with ${s}"; exit ${s}' ERR
          retry() {
            for i in {1..10}; do
              if "$@"; then
                return 0
              else
                sleep "${i}"
              fi
            done
            "$@"
          }
          bail() {
            printf '::error::%s\n' "$*"
            exit 1
          }
          normalize_comma_or_space_separated() {
            # Normalize whitespace characters into space because it's hard to handle single input contains lines with POSIX sed alone.
            local list="${1//[$'\r\n\t']/ }"
            if [[ "${list}" == *","* ]]; then
              # If a comma is contained, consider it is a comma-separated list.
              # Drop leading and trailing whitespaces in each element.
              sed -E 's/ *, */,/g; s/^.//' <<<",${list},"
            else
              # Otherwise, consider it is a whitespace-separated list.
              # Convert whitespace characters into comma.
              sed -E 's/ +/,/g; s/^.//' <<<" ${list} "
            fi
          }
          args=()
          if [[ "${INPUT_ARGS}" != *"-features"* ]]; then
            args+=(--all-features)
          fi
          if [[ -n "${INPUT_ARGS}" ]]; then
            while read -rd' '; do
              [[ -z "${REPLY}" ]] || args+=("${REPLY}")
            done <<<"${INPUT_ARGS//[$'\r\n\t']/ } " # Normalize whitespace characters into space.
          fi
          host=$(rustc -vV | grep -E '^host:' | cut -d' ' -f2)
          metadata=$(cargo metadata --format-version=1 --no-deps)
          # Handle target inputs.
          run_host=''
          targets=()
          tier3_targets=()
          if [[ -n "${INPUT_TARGET}" ]]; then
            while read -rd,; do
              if [[ "${REPLY}" == "${host}" ]] || [[ "${REPLY}" == 'host' ]]; then
                run_host=1
              elif rustup target list | cut -d' ' -f1 | grep -Eq "^${REPLY}$"; then
                retry rustup target add "${REPLY}"
                targets+=(--target="${REPLY}")
              else
                tier3_targets+=(--target="${REPLY}")
              fi
            done < <(normalize_comma_or_space_separated "${INPUT_TARGET}")
          else
            run_host=1
          fi
          if [[ -n "${RUSTDOCFLAGS:-}" ]]; then
              printf '%s\n' "+ RUSTDOCFLAGS='${RUSTDOCFLAGS}' \\"
          fi
          export RUSTFLAGS="${RUSTFLAGS} -Z crate-attr=feature(unqualified_local_imports) -D unqualified_local_imports"
          if [[ -n ${run_host} ]]; then
            # Do not pass --target for the target that same as host as RUSTFLAGS is not applied for host when --target option passed.
            (
              # core/alloc/std sets feature(strict_provenance_lints), so we cannot use
              # -Z crate-attr=feature(strict_provenance_lints) when -Z build-std is needed.
              # shellcheck disable=SC2030
              export RUSTFLAGS="${RUSTFLAGS} -Z crate-attr=feature(strict_provenance_lints) -D fuzzy_provenance_casts"
              printf '%s\n' "+ RUSTFLAGS='${RUSTFLAGS}' \\"
              set -x
              cargo clippy --workspace --all-targets "${args[@]}"
            )
          fi
          if [[ ${#targets[@]} -gt 0 ]]; then
            (
              # core/alloc/std sets feature(strict_provenance_lints), so we cannot use
              # -Z crate-attr=feature(strict_provenance_lints) when -Z build-std is needed.
              # shellcheck disable=SC2030,SC2031
              export RUSTFLAGS="${RUSTFLAGS} -Z crate-attr=feature(strict_provenance_lints) -D fuzzy_provenance_casts"
              printf '%s\n' "+ RUSTFLAGS='${RUSTFLAGS}' \\"
              set -x
              cargo clippy --workspace --all-targets "${targets[@]}" "${args[@]}"
            )
          fi
          if [[ ${#tier3_targets[@]} -gt 0 ]]; then
            # shellcheck disable=SC2031
            if [[ -n "${RUSTFLAGS:-}" ]]; then
                printf '%s\n' "+ RUSTFLAGS='${RUSTFLAGS}' \\"
            fi
            retry rustup component add rust-src
            for target in "${tier3_targets[@]}"; do
              (
                set -x
                cargo clippy --workspace --all-targets "${target}" -Z build-std "${args[@]}"
              )
            done
          fi
          # Refs:
          # - https://github.com/rust-lang/rust/issues/56232
          # - https://github.com/Nemo157/dotfiles/blob/cee1b90cb23089990fe9bc559b7c2f012d0a59f0/packages/cargo-rustdoc-clippy.sh
          lints=$(pipx run --spec yq tomlq -c 'if .workspace then .workspace.lints else null end' Cargo.toml)
          if [[ "${lints}" == 'null' ]]; then
            lints='{}'
          fi
          clippy_args=(
            -D warnings
          )
          while IFS='' read -r; do
            [[ -n "${REPLY}" ]] || continue
            if [[ "${REPLY}" == 'unexpected_cfgs' ]] || [[ "${REPLY}" == 'unexpected-cfgs' ]]; then
              check_cfg="$(jq -c 'if (.rust."'"${REPLY}"'" | type == "object") then .rust."'"${REPLY}"'"."check-cfg" else null end' <<<"${lints}")"
              if [[ "${check_cfg}" != 'null' ]] && [[ "${check_cfg}" != '[]' ]]; then
                # TODO: check-cfg
                clippy_args+=(-A "${REPLY}")
                continue
              fi
            fi
            clippy_args+=(-D "${REPLY}")
          done <<<"$(jq -r 'if .rust then .rust | to_entries[] | select((.value == "allow" or ((.value | type == "object") and .value.level == "allow")) | not) | .key else empty end' <<<"${lints}")"
          while IFS='' read -r; do
            [[ -n "${REPLY}" ]] || continue
            clippy_args+=(-A "${REPLY}")
          done <<<"$(jq -r 'if .rust then .rust | to_entries[] | select(.value == "allow" or ((.value | type == "object") and .value.level == "allow")) | .key else empty end' <<<"${lints}")"
          while IFS='' read -r; do
            [[ -n "${REPLY}" ]] || continue
            clippy_args+=(-D "clippy::${REPLY}")
          done <<<"$(jq -r 'if .clippy then .clippy | to_entries[] | select((.value == "allow" or ((.value | type == "object") and .value.level == "allow")) | not) | .key else empty end' <<<"${lints}")"
          while IFS='' read -r; do
            [[ -n "${REPLY}" ]] || continue
            clippy_args+=(-A "clippy::${REPLY}")
          done <<<"$(jq -r 'if .clippy then .clippy | to_entries[] | select(.value == "allow" or ((.value | type == "object") and .value.level == "allow")) | .key else empty end' <<<"${lints}")"
          # Lints emitted for code generated by rustdoc.
          clippy_args+=(
            -A clippy::semicolon_if_nothing_returned
            -A clippy::used_underscore_items
          )
          IFS=' '
          cat >/tmp/clippy-wrapper.sh <<EOF
          #!/bin/sh
          set -eu
          clippy-driver ${clippy_args[*]} "\$@"
          EOF
          printf '%s\n' "+ cat -- /tmp/clippy-wrapper.sh"
          cat -- /tmp/clippy-wrapper.sh
          chmod +x /tmp/clippy-wrapper.sh
          IFS=$'\n\t'
          export RUSTDOCFLAGS="${RUSTDOCFLAGS:-} -Z unstable-options --no-run --test-builder /tmp/clippy-wrapper.sh"
          printf '%s\n' "+ RUSTDOCFLAGS='${RUSTDOCFLAGS}' \\"
          for manifest_path in $(jq -r '. as $metadata | .workspace_members[] as $id | $metadata.packages[] | select(.id == $id and .targets[].doctest == true) | .manifest_path' <<<"${metadata}"); do
            use_workspace_lints=$(pipx run --spec yq tomlq -c 'if .lints and .lints.workspace then .lints.workspace else false end' "${manifest_path}")
            if [[ "${use_workspace_lints}" != 'true' ]]; then
              bail "'.lints.workspace = true must be set'"
            fi
            (
              set -x
              cargo test --manifest-path "${manifest_path}" --doc "${args[@]}" -- --nocapture
            )
          done
        env:
          INPUT_ARGS: ${{ inputs.args }}
          INPUT_TARGET: ${{ inputs.target }}
