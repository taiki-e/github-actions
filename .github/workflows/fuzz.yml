# Build fuzzing code with `cargo fuzz`, `cargo afl`, and `cargo hfuzz`, and run fuzzing with `cargo afl` on scheduled run.
#
# There is no stability guarantee for this workflow, since it's supposed to only be
# used in infra managed by us.
#
# Usage:
#
# ```yml
#   test:
#     uses: taiki-e/github-actions/.github/workflows/fuzz.yml@main
# ```
#
# See "on.workflow_call.inputs" below for input options.

permissions:
  contents: read

on:
  workflow_call:
    inputs:
      rust:
        required: false
        type: string
        default: nightly
      # TODO: more inputs

env:
  CARGO_INCREMENTAL: 0
  CARGO_NET_GIT_FETCH_WITH_CLI: true
  CARGO_NET_RETRY: 10
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  RUSTFLAGS: -D warnings
  RUSTDOCFLAGS: -D warnings
  RUSTUP_MAX_RETRIES: 10
  # Reusable workflows cannot inherit environment variables.
  ATOMIC_MAYBE_UNINIT_DENY_WARNINGS: 1
  CARGO_HACK_DENY_WARNINGS: 1
  CARGO_LLVM_COV_DENY_WARNINGS: 1
  CARGO_MINIMAL_VERSIONS_DENY_WARNINGS: 1
  CARGO_NO_DEV_DEPS_DENY_WARNINGS: 1
  CONST_FN_DENY_WARNINGS: 1
  PORTABLE_ATOMIC_DENY_WARNINGS: 1
  SEMIHOSTING_DENY_WARNINGS: 1
  FUZZ_MAX_TOTAL_TIME: 300 # 5 minute

defaults:
  run:
    shell: bash --noprofile --norc -CeEuo pipefail {0}

jobs:
  fuzz:
    runs-on: ubuntu-latest
    timeout-minutes: 180
    steps:
      - uses: taiki-e/checkout-action@v1
      - uses: taiki-e/github-actions/free-device-space@main
        if: github.event_name == 'schedule'
      - uses: taiki-e/github-actions/install-rust@main
        with:
          toolchain: ${{ inputs.rust }}
      - run: sudo apt-get -o Acquire::Retries=10 -qq update && sudo apt-get -o Acquire::Retries=10 -o Dpkg::Use-Pty=0 install -y --no-install-recommends binutils-dev libunwind8-dev
      - uses: taiki-e/cache-cargo-install-action@v2
        with:
          tool: cargo-fuzz
      # We cannot use cache for cargo-afl because afl.rs requires the cargo-afl binary and afl library to be built with the same compiler version.
      - run: cargo install cargo-afl --debug --locked
      - uses: taiki-e/cache-cargo-install-action@v2
        with:
          # TODO: Pass --no-default-features
          tool: honggfuzz
      - run: cargo fuzz build --features libfuzzer
      - run: cargo afl build --release --features afl
        working-directory: fuzz
      - run: |
          HFUZZ_BUILD_ARGS="--features honggfuzz" \
            RUSTFLAGS="${RUSTFLAGS:-} -Z sanitizer=address" \
            cargo hfuzz build
        working-directory: fuzz
      # On scheduled job, run fuzzer $FUZZ_MAX_TOTAL_TIME seconds per target.
      # TODO: This is currently skipped for libfuzzer due to https://github.com/rust-fuzz/cargo-fuzz/issues/270.
      # TODO: Honggfuzz
      - name: Cache AFL++ output
        uses: actions/cache@v5
        with:
          path: fuzz/out
          key: afl-out-${{ github.run_id }}
          restore-keys: afl-out-
        if: github.event_name == 'schedule'
      - name: Fuzzing with AFL++
        run: |
          ulimit -S -c unlimited
          sudo tee -- /proc/sys/kernel/core_pattern >/dev/null <<<core
          # shellcheck disable=SC2010
          for target in $(ls | grep -E '\.rs$' | sed -E 's/\.rs$//'); do
            cargo afl fuzz -i "seeds/${target}" -o "out/${target}" -V "${FUZZ_MAX_TOTAL_TIME}" "target/release/${target}"
            rmdir -- "out/${target}/default/crashes" 2>/dev/null || true
            rmdir -- "out/${target}/default/hangs" 2>/dev/null || true
            if [[ -d "out/${target}/default/crashes" ]] || [[ -d "out/${target}/default/hangs" ]]; then
              exit 1
            fi
          done
        working-directory: fuzz
        if: github.event_name == 'schedule'
      - name: Archive artifacts
        run: |
          if [[ -d out ]]; then
            tar acvf ../afl-artifacts.tar.gz out
          fi
        working-directory: fuzz
        if: failure() && github.event_name == 'schedule'
      - name: Upload artifacts
        uses: actions/upload-artifact@v6
        with:
          name: fuzz-artifacts
          path: afl-artifacts.tar.gz
        if: failure() && github.event_name == 'schedule'
