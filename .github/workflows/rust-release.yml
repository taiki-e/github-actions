# Create and push the release commit and tag, create GitHub release, and publish crates.
#
# There is no stability guarantee for this workflow, since it's supposed to only be
# used in infra managed by us.
#
# Note: This uses token-based publish for initial publish which Trusted Publishing doesn't work.
# Otherwise Trusted Publishing is used.
#
# Setup (common):
#
# 1. Visit https://github.com/<owner>/<repo>/settings/environments
#    and create "release" environment.
#
# 2. If only selected actions are allowed,
#    Visit https://github.com/<owner>/<repo>/settings/actions
#    and add the followings to allowed actions:
#
#    rust-lang/crates-io-auth-action@*,
#    taiki-e/*,
#
# Setup (initial publish):
#
# 1. Visit https://crates.io/settings/tokens
#    and create an API token with "publish-new" scope.
#
# 2. Visit https://github.com/<owner>/<repo>/settings/environments
#    and create a environment secret named "CARGO_REGISTRY_TOKEN"
#    with the API token created above.
#
# Setup (non-initial publish):
#
# 1. Visit https://crates.io/crates/<crate-name>/settings
#    and add Trusted Publishing setting, like:
#
#    Repository: <owner>/<repo>
#    Workflow: release.yml
#    Environment: release
#
# 2. If you used token-based publish for initial publish,
#    remove the API token on crates.io and the corresponding secret.
#
# Usage:
#
# (Please fill `<owner>` with the actual repository owner name.)
#
# ```yml
# on:
#   workflow_dispatch:
#     inputs:
#       version:
#         description: Version to be increased
#         required: true
#         type: choice
#         options:
#           - patch
#           - minor
#           - major
#
#   publish:
#     if: github.repository_owner == '<owner>'
#     uses: taiki-e/github-actions/.github/workflows/rust-release.yml@main
#     permissions:
#       contents: write # for taiki-e/create-gh-release-action
#       id-token: write # for rust-lang/crates-io-auth-action
#     secrets: inherit
#     with:
#       version: ${{ inputs.version }}
# ```
#
# Or:
#
# ```yml
# on:
#   workflow_dispatch:
#     inputs:
#       version:
#         description: Version to be published
#         required: true
#         type: string
#
#   publish:
#     if: github.repository_owner == '<owner>'
#     uses: taiki-e/github-actions/.github/workflows/rust-release.yml@main
#     permissions:
#       contents: write # for taiki-e/create-gh-release-action
#       id-token: write # for rust-lang/crates-io-auth-action
#     secrets: inherit
#     with:
#       version: ${{ inputs.version }}
# ```
#
# See "on.workflow_call.inputs" below for input options.

# TODO: Remove token-based one by requiring publish of 0.0.0 version on crates.io?

permissions:
  contents: read

on:
  workflow_call:
    inputs:
      version:
        required: true
        type: string
      tag-prefix:
        required: false
        type: string
        default: v
      rust:
        required: false
        type: string
        default: stable
      target:
        required: false
        type: string
      args:
        required: false
        type: string
      crates:
        required: false
        type: string
        default: '.'
      changelog:
        required: false
        type: string
        default: CHANGELOG.md
      title:
        required: false
        type: string
        default: $version
      branch:
        required: false
        type: string
        default: main
      prefix:
        required: false
        type: string
    outputs:
      ref:
        value: refs/tags/${{ jobs.prepare.outputs.tag }}
      rev:
        value: ${{ jobs.release.outputs.rev }}

env:
  CARGO_INCREMENTAL: 0
  CARGO_NET_GIT_FETCH_WITH_CLI: true
  CARGO_NET_RETRY: 10
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  RUSTFLAGS: -D warnings
  RUSTDOCFLAGS: -D warnings
  RUSTUP_MAX_RETRIES: 10

defaults:
  run:
    shell: bash --noprofile --norc -CeEuo pipefail {0}

jobs:
  prepare:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - uses: taiki-e/checkout-action@v1
      - uses: taiki-e/install-action@v2
        with:
          tool: parse-changelog
      - uses: taiki-e/github-actions/install-rust@main
        with:
          toolchain: ${{ inputs.rust }}
          target: ${{ inputs.target }}
      - id: check
        run: |
          IFS=$'\n\t'
          trap -- 's=$?; printf >&2 "%s\n" "${0##*/}:${LINENO}: \`${BASH_COMMAND}\` exit with ${s}"; exit ${s}' ERR
          bail() {
            printf >&2 'error: %s\n' "$*"
            exit 1
          }
          normalize_comma_or_space_separated() {
            # Normalize whitespace characters into space because it's hard to handle single input contains lines with POSIX sed alone.
            local list="${1//[$'\r\n\t']/ }"
            if [[ "${list}" == *","* ]]; then
              # If a comma is contained, consider it is a comma-separated list.
              # Drop leading and trailing whitespaces in each element.
              sed -E 's/ *, */,/g; s/^.//' <<<",${list},"
            else
              # Otherwise, consider it is a whitespace-separated list.
              # Convert whitespace characters into comma.
              sed -E 's/ +/,/g; s/^.//' <<<" ${list} "
            fi
          }
          if { sed --help 2>&1 || true; } | grep -Eq -e '-i extension'; then
            in_place=(-i '')
          else
            in_place=(-i)
          fi

          # shellcheck disable=SC2153
          version="${VERSION}"
          printf '%s\n' "version(input): ${version}"
          # shellcheck disable=SC2153
          tag_prefix="${TAG_PREFIX}"
          printf '%s\n' "tag_prefix: ${tag_prefix}"
          # shellcheck disable=SC2153
          changelog="${CHANGELOG}"
          printf '%s\n' "changelog: ${changelog}"

          # Get the current date.
          release_date=$(date -u '+%Y-%m-%d')
          printf '%s\n' "release-date: ${release_date}"
          printf '%s\n' "release-date=${release_date}" >>"${GITHUB_OUTPUT}"

          # Get the current revision.
          git fetch origin &>/dev/null
          rev=$(git rev-parse HEAD)
          printf '%s\n' "rev: ${rev}"
          printf '%s\n' "rev=${rev}" >>"${GITHUB_OUTPUT}"

          # Get the previous version.
          metadata=$(cargo metadata --format-version=1 --no-deps)
          prev_version=''
          # Publishing is unrestricted if null, and forbidden if an empty array.
          for pkg in $(jq -c '. as $metadata | .workspace_members[] as $id | $metadata.packages[] | select(.id == $id and .publish != [])' <<<"${metadata}"); do
            eval "$(jq -r '@sh "NAME=\(.name) ACTUAL_VERSION=\(.version) MANIFEST_PATH=\(.manifest_path)"' <<<"${pkg}")"
            if [[ -z "${prev_version}" ]]; then
              prev_version="${ACTUAL_VERSION}"
            fi
            # Make sure that the version number of all publishable workspace members matches.
            if [[ "${ACTUAL_VERSION}" != "${prev_version}" ]]; then
              bail "publishable workspace members must be version '${prev_version}', but package '${NAME}' is version '${ACTUAL_VERSION}'"
            fi
            # Make sure that the version marker is available.
            if ! grep -Eq "^version = \"${prev_version}\" #publish:version" "${MANIFEST_PATH}"; then
              bail "not found '#publish:version' in version in ${MANIFEST_PATH}"
            fi
          done
          printf '%s\n' "prev-version: ${prev_version}"
          printf '%s\n' "prev-version=${prev_version}" >>"${GITHUB_OUTPUT}"

          # Determine the new version number and tag name.
          case "${version}" in
            major | minor | patch)
              if [[ ! "${prev_version}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                bail "pre-release/build-metadata"
              fi
              major="${prev_version%%.*}"
              minor_patch="${prev_version#*.}"
              minor="${minor_patch%%.*}"
              patch="${minor_patch#*.}"
              case "${version}" in
                major) version="$((major+1)).0.0" ;;
                minor) version="${major}.$((minor+1)).0" ;;
                patch) version="${major}.${minor}.$((patch+1))" ;;
              esac
              ;;
            *) version="${version#v}" ;;
          esac
          if [[ ! "${version}" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z\.-]+)?(\+[0-9A-Za-z\.-]+)?$ ]]; then
            bail "invalid version format '${version}'"
          fi
          printf '%s\n' "version: ${version}"
          printf '%s\n' "version=${version}" >>"${GITHUB_OUTPUT}"
          tag="${tag_prefix}${version}"
          printf '%s\n' "tag: ${tag}"
          printf '%s\n' "tag=${tag}" >>"${GITHUB_OUTPUT}"

          # Make sure the same release has not been created in the past.
          if gh release view "${tag}" &>/dev/null; then
            bail "tag '${tag}' has already been created and pushed"
          fi
          # Make sure that the release was created from an allowed branch.
          if ! git branch | grep -Eq '\* '"${BRANCH}"'$'; then
            bail "current branch is not '${BRANCH}'"
          fi

          changed_paths=()
          git fetch origin --tags &>/dev/null
          tags=$(git --no-pager tag | { grep -E "^${tag_prefix}[0-9]+" || true; })
          if [[ -n "${tags}" ]]; then
            printf 'has-tags=true\n' >>"${GITHUB_OUTPUT}"
            # Make sure the same release does not exist in changelog.
            if grep -Eq "^## \\[${version//./\\.}\\]" "${changelog}"; then
              bail "release ${version} already exist in ${changelog}"
            fi
            if grep -Eq "^\\[${version//./\\.}\\]: " "${changelog}"; then
              bail "link to ${version} already exist in ${changelog}"
            fi

            # Update changelog.
            changed_paths+=("${changelog}")
            remote_url=$(grep -E '^\[Unreleased\]: https://' "${changelog}" | sed -E 's/^\[Unreleased\]: //; s/\.\.\.HEAD$//')
            prev_tag="${remote_url#*/compare/}"
            remote_url="${remote_url%/compare/*}"
            sed -E "${in_place[@]}" \
              -e "s/^## \\[Unreleased\\]/## [Unreleased]\\n\\n## [${version}] - ${release_date}/" \
              -e "s#^\[Unreleased\]: https://.*#[Unreleased]: ${remote_url}/compare/${tag}...HEAD\\n[${version}]: ${remote_url}/compare/${prev_tag}...${tag}#" "${changelog}"
            if ! grep -Eq "^## \\[${version//./\\.}\\] - ${release_date}$" "${changelog}"; then
              bail "failed to update ${changelog}"
            fi
            if ! grep -Eq "^\\[${version//./\\.}\\]: " "${changelog}"; then
              bail "failed to update ${changelog}"
            fi
          else
            # Make sure the release exists in changelog.
            if ! grep -Eq "^## \\[${version//./\\.}\\] - ${release_date}$" "${changelog}"; then
              bail "release ${version} does not exist in ${changelog} or has wrong release date"
            fi
            if ! grep -Eq "^\\[${version//./\\.}\\]: " "${changelog}"; then
              bail "link to ${version} does not exist in ${changelog}"
            fi
          fi
          # Make sure that a valid release note for this version exists.
          # https://github.com/taiki-e/parse-changelog
          changes=$(parse-changelog "${changelog}" "${version}")
          if [[ -z "${changes}" ]]; then
            bail "changelog for ${version} has no body"
          fi
          printf '============== CHANGELOG ==============\n'
          printf '%s\n' "${changes}"
          printf '=======================================\n'

          docs=()
          for readme in $(git ls-files '*README.md'); do
            docs+=("${readme}")
            lib="$(dirname -- "${readme}")/src/lib.rs"
            if [[ -f "${lib}" ]]; then
              docs+=("${lib}")
            fi
          done
          changed_paths+=("${docs[@]}")
          # Publishing is unrestricted if null, and forbidden if an empty array.
          for pkg in $(jq -c '. as $metadata | .workspace_members[] as $id | $metadata.packages[] | select(.id == $id and .publish != [])' <<<"${metadata}"); do
            eval "$(jq -r '@sh "NAME=\(.name) MANIFEST_PATH=\(.manifest_path)"' <<<"${pkg}")"
            changed_paths+=("${MANIFEST_PATH}")
            # Update version in Cargo.toml.
            sed -E "${in_place[@]}" "s/^version = \"${prev_version}\" #publish:version/version = \"${version}\" #publish:version/g" "${MANIFEST_PATH}"
            # Update '=' requirement in Cargo.toml.
            for manifest in $(git ls-files '*Cargo.toml'); do
              if grep -Eq "^${NAME} = \\{ version = \"=${prev_version}\"" "${manifest}"; then
                sed -E "${in_place[@]}" "s/^${NAME} = \\{ version = \"=${prev_version}\"/${NAME} = { version = \"=${version}\"/g" "${manifest}"
                changed_paths+=("${manifest}")
              fi
            done
            # Update version in readme and lib.rs.
            for path in "${docs[@]}"; do
              # TODO: handle pre-release
              if [[ "${version}" == "0.0."* ]]; then
                # 0.0.x -> 0.0.y
                if grep -Eq "^${NAME} = \"${prev_version}\"" "${path}"; then
                  sed -E "${in_place[@]}" "s/^${NAME} = \"${prev_version}\"/${NAME} = \"${version}\"/g" "${path}"
                fi
                if grep -Eq "^${NAME} = \\{ version = \"${prev_version}\"" "${path}"; then
                  sed -E "${in_place[@]}" "s/^${NAME} = \\{ version = \"${prev_version}\"/${NAME} = { version = \"${version}\"/g" "${path}"
                fi
              elif [[ "${version}" == "0."* ]]; then
                prev_major_minor="${prev_version%.*}"
                major_minor="${version%.*}"
                if [[ "${prev_major_minor}" != "${major_minor}" ]]; then
                  # 0.x -> 0.y
                  # 0.x.* -> 0.y
                  if grep -Eq "^${NAME} = \"${prev_major_minor}(\\.[0-9]+)?\"" "${path}"; then
                    sed -E "${in_place[@]}" "s/^${NAME} = \"${prev_major_minor}(\\.[0-9]+)?\"/${NAME} = \"${major_minor}\"/g" "${path}"
                  fi
                  if grep -Eq "^${NAME} = \\{ version = \"${prev_major_minor}(\\.[0-9]+)?\"" "${path}"; then
                    sed -E "${in_place[@]}" "s/^${NAME} = \\{ version = \"${prev_major_minor}(\\.[0-9]+)?\"/${NAME} = { version = \"${major_minor}\"/g" "${path}"
                  fi
                fi
              else
                prev_major="${prev_version%%.*}"
                major="${version%%.*}"
                if [[ "${prev_major}" != "${major}" ]]; then
                  # x -> y
                  # x.* -> y
                  # x.*.* -> y
                  if grep -Eq "^${NAME} = \"${prev_major}(\\.[0-9]+(\\.[0-9]+)?)?\"" "${path}"; then
                    sed -E "${in_place[@]}" "s/^${NAME} = \"${prev_major}(\\.[0-9]+(\\.[0-9]+)?)?\"/${NAME} = \"${major}\"/g" "${path}"
                  fi
                  if grep -Eq "^${NAME} = \\{ version = \"${prev_major}(\\.[0-9]+(\\.[0-9]+)?)?\"" "${path}"; then
                    sed -E "${in_place[@]}" "s/^${NAME} = \\{ version = \"${prev_major}(\\.[0-9]+(\\.[0-9]+)?)?\"/${NAME} = { version = \"${major}\"/g" "${path}"
                  fi
                fi
              fi
            done
          done

          if [[ -n "${tags}" ]]; then
            git -c color.ui=always diff "${changed_paths[@]}"
            git add "${changed_paths[@]}"
          fi
          # Make sure that there is no unintended change.
          git add -N .
          git -c color.ui=always diff --exit-code

          (
            set -x
            git show HEAD --shortstat
          )

          crates=$(normalize_comma_or_space_separated "${INPUT_CRATES}")
          printf '%s\n' "crates=${crates}" >>"${GITHUB_OUTPUT}"
        env:
          VERSION: ${{ inputs.version }}
          TAG_PREFIX: ${{ inputs.tag-prefix }}
          CHANGELOG: ${{ inputs.changelog }}
          BRANCH: ${{ inputs.branch }}
          INPUT_CRATES: ${{ inputs.crates }}
      - name: Build crates to be published
        run: |
          IFS=$'\n\t'
          trap -- 's=$?; printf >&2 "%s\n" "${0##*/}:${LINENO}: \`${BASH_COMMAND}\` exit with ${s}"; exit ${s}' ERR
          args=()
          [[ -z "${INPUT_TARGET}" ]] || args+=(--target "${INPUT_TARGET}")
          if [[ -n "${INPUT_ARGS}" ]]; then
            while read -rd' '; do
              [[ -z "${REPLY}" ]] || args+=("${REPLY}")
            done <<<"${INPUT_ARGS//[$'\r\n\t']/ } " # Normalize whitespace characters into space.
          fi
          while read -rd,; do
            (
              set -x
              cd -- "${REPLY}"
              cargo build "${args[@]}"
            )
          done <<<"${INPUT_CRATES}"
        env:
          INPUT_ARGS: ${{ inputs.args }}
          INPUT_CRATES: ${{ steps.check.outputs.crates }}
          INPUT_TARGET: ${{ inputs.target }}
    outputs:
      has-tags: ${{ steps.check.outputs.has-tags }}
      release-date: ${{ steps.check.outputs.release-date }}
      rev: ${{ steps.check.outputs.rev }}
      tag: ${{ steps.check.outputs.tag }}
      version: ${{ steps.check.outputs.version }}
      prev-version: ${{ steps.check.outputs.prev-version }}
      crates: ${{ steps.check.outputs.crates }}

  release:
    needs: prepare
    runs-on: ubuntu-latest
    timeout-minutes: 60
    environment: release
    permissions:
      contents: write # for taiki-e/create-gh-release-action
      id-token: write # for rust-lang/crates-io-auth-action
    steps:
      - uses: taiki-e/checkout-action@v1
      - uses: taiki-e/install-action@v2
        with:
          tool: parse-changelog
      - uses: taiki-e/github-actions/install-rust@main
        with:
          toolchain: ${{ inputs.rust }}
          target: ${{ inputs.target }}
      - name: Create and push release commit and tag
        id: push
        run: |
          IFS=$'\n\t'
          trap -- 's=$?; printf >&2 "%s\n" "${0##*/}:${LINENO}: \`${BASH_COMMAND}\` exit with ${s}"; exit ${s}' ERR
          retry() {
            for i in {1..10}; do
              if "$@"; then
                return 0
              else
                sleep "${i}"
              fi
            done
            "$@"
          }
          bail() {
            printf >&2 'error: %s\n' "$*"
            exit 1
          }
          if { sed --help 2>&1 || true; } | grep -Eq -e '-i extension'; then
            in_place=(-i '')
          else
            in_place=(-i)
          fi

          git config user.name 'Taiki Endo'
          git config user.email 'te316e89@gmail.com'

          # shellcheck disable=SC2153
          version="${VERSION}"
          # shellcheck disable=SC2153
          prev_version="${PREV_VERSION}"
          # shellcheck disable=SC2153
          tag="${TAG}"
          # shellcheck disable=SC2153
          changelog="${CHANGELOG}"
          # shellcheck disable=SC2153
          release_date="${RELEASE_DATE}"

          # Make sure the current revision is same as prepare step.
          git fetch origin &>/dev/null
          rev=$(git rev-parse HEAD)
          if [[ "${rev}" != "${PREPARE_REV}" ]]; then
            bail "revision difference between prepare step"
          fi

          # Make sure the same release has not been created in the past.
          if gh release view "${tag}" &>/dev/null; then
            bail "tag '${tag}' has already been created and pushed"
          fi
          # Make sure that the release was created from an allowed branch.
          if ! git branch | grep -Eq '\* '"${BRANCH}"'$'; then
            bail "current branch is not '${BRANCH}'"
          fi

          metadata=$(cargo metadata --format-version=1 --no-deps)

          changed_paths=()
          if [[ "${HAS_TAGS}" == "true" ]]; then
            # Update changelog.
            changed_paths+=("${changelog}")
            remote_url=$(grep -E '^\[Unreleased\]: https://' "${changelog}" | sed -E 's/^\[Unreleased\]: //; s/\.\.\.HEAD$//')
            prev_tag="${remote_url#*/compare/}"
            remote_url="${remote_url%/compare/*}"
            sed -E "${in_place[@]}" \
              -e "s/^## \\[Unreleased\\]/## [Unreleased]\\n\\n## [${version}] - ${release_date}/" \
              -e "s#^\[Unreleased\]: https://.*#[Unreleased]: ${remote_url}/compare/${tag}...HEAD\\n[${version}]: ${remote_url}/compare/${prev_tag}...${tag}#" "${changelog}"
            if ! grep -Eq "^## \\[${version//./\\.}\\] - ${release_date}$" "${changelog}"; then
              bail "failed to update ${changelog}"
            fi
            if ! grep -Eq "^\\[${version//./\\.}\\]: " "${changelog}"; then
              bail "failed to update ${changelog}"
            fi
          fi
          changes=$(parse-changelog "${changelog}" "${version}")
          printf '============== CHANGELOG ==============\n'
          printf '%s\n' "${changes}"
          printf '=======================================\n'

          docs=()
          for readme in $(git ls-files '*README.md'); do
            docs+=("${readme}")
            lib="$(dirname -- "${readme}")/src/lib.rs"
            if [[ -f "${lib}" ]]; then
              docs+=("${lib}")
            fi
          done
          changed_paths+=("${docs[@]}")
          # Publishing is unrestricted if null, and forbidden if an empty array.
          for pkg in $(jq -c '. as $metadata | .workspace_members[] as $id | $metadata.packages[] | select(.id == $id and .publish != [])' <<<"${metadata}"); do
            eval "$(jq -r '@sh "NAME=\(.name) MANIFEST_PATH=\(.manifest_path)"' <<<"${pkg}")"
            changed_paths+=("${MANIFEST_PATH}")
            # Update version in Cargo.toml.
            sed -E "${in_place[@]}" "s/^version = \"${prev_version}\" #publish:version/version = \"${version}\" #publish:version/g" "${MANIFEST_PATH}"
            # Update '=' requirement in Cargo.toml.
            for manifest in $(git ls-files '*Cargo.toml'); do
              if grep -Eq "^${NAME} = \\{ version = \"=${prev_version}\"" "${manifest}"; then
                sed -E "${in_place[@]}" "s/^${NAME} = \\{ version = \"=${prev_version}\"/${NAME} = { version = \"=${version}\"/g" "${manifest}"
                changed_paths+=("${manifest}")
              fi
            done
            # Update version in readme and lib.rs.
            for path in "${docs[@]}"; do
              # TODO: handle pre-release
              if [[ "${version}" == "0.0."* ]]; then
                # 0.0.x -> 0.0.y
                if grep -Eq "^${NAME} = \"${prev_version}\"" "${path}"; then
                  sed -E "${in_place[@]}" "s/^${NAME} = \"${prev_version}\"/${NAME} = \"${version}\"/g" "${path}"
                fi
                if grep -Eq "^${NAME} = \\{ version = \"${prev_version}\"" "${path}"; then
                  sed -E "${in_place[@]}" "s/^${NAME} = \\{ version = \"${prev_version}\"/${NAME} = { version = \"${version}\"/g" "${path}"
                fi
              elif [[ "${version}" == "0."* ]]; then
                prev_major_minor="${prev_version%.*}"
                major_minor="${version%.*}"
                if [[ "${prev_major_minor}" != "${major_minor}" ]]; then
                  # 0.x -> 0.y
                  # 0.x.* -> 0.y
                  if grep -Eq "^${NAME} = \"${prev_major_minor}(\\.[0-9]+)?\"" "${path}"; then
                    sed -E "${in_place[@]}" "s/^${NAME} = \"${prev_major_minor}(\\.[0-9]+)?\"/${NAME} = \"${major_minor}\"/g" "${path}"
                  fi
                  if grep -Eq "^${NAME} = \\{ version = \"${prev_major_minor}(\\.[0-9]+)?\"" "${path}"; then
                    sed -E "${in_place[@]}" "s/^${NAME} = \\{ version = \"${prev_major_minor}(\\.[0-9]+)?\"/${NAME} = { version = \"${major_minor}\"/g" "${path}"
                  fi
                fi
              else
                prev_major="${prev_version%%.*}"
                major="${version%%.*}"
                if [[ "${prev_major}" != "${major}" ]]; then
                  # x -> y
                  # x.* -> y
                  # x.*.* -> y
                  if grep -Eq "^${NAME} = \"${prev_major}(\\.[0-9]+(\\.[0-9]+)?)?\"" "${path}"; then
                    sed -E "${in_place[@]}" "s/^${NAME} = \"${prev_major}(\\.[0-9]+(\\.[0-9]+)?)?\"/${NAME} = \"${major}\"/g" "${path}"
                  fi
                  if grep -Eq "^${NAME} = \\{ version = \"${prev_major}(\\.[0-9]+(\\.[0-9]+)?)?\"" "${path}"; then
                    sed -E "${in_place[@]}" "s/^${NAME} = \\{ version = \"${prev_major}(\\.[0-9]+(\\.[0-9]+)?)?\"/${NAME} = { version = \"${major}\"/g" "${path}"
                  fi
                fi
              fi
            done
          done

          if [[ "${HAS_TAGS}" == "true" ]]; then
            # Create a release commit.
            (
              set -x
              git add "${changed_paths[@]}"
              git commit -m "Release ${version}"
            )
          fi
          rev=$(git rev-parse HEAD)
          printf '%s\n' "rev: ${rev}"
          printf '%s\n' "rev=${rev}" >>"${GITHUB_OUTPUT}"

          prev_credential_helper=$(git config get --global credential.helper || true)
          if [[ -n "${prev_credential_helper}" ]]; then
            printf 'credential helper is already set (%s)\n' "${prev_credential_helper}"
          else
            (
              set -x
              git config --global credential.helper store
            )
            protocol="${GITHUB_SERVER_URL%%://*}"
            hostname="${GITHUB_SERVER_URL#*://}"
            printf '%s\n' "${protocol}://${GITHUB_ACTOR}:${PUSH_TOKEN}@${hostname}" >~/.git-credentials
            # Remove credential helper config on exit.
            trap -- '(set -x; rm -f -- ~/.git-credentials; git config --global --unset credential.helper || true)' EXIT
          fi

          (
            set -x
            git tag "${tag}"
            retry git push origin refs/heads/main
            retry git push origin refs/tags/"${tag}"
          )
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
          PREV_VERSION: ${{ needs.prepare.outputs.prev-version }}
          RELEASE_DATE: ${{ needs.prepare.outputs.release-date }}
          HAS_TAGS: ${{ needs.prepare.outputs.has-tags }}
          TAG: ${{ needs.prepare.outputs.tag }}
          CHANGELOG: ${{ inputs.changelog }}
          BRANCH: ${{ inputs.branch }}
          PREPARE_REV: ${{ needs.prepare.outputs.rev }}
          # Re-use CREATE_PR_TOKEN which has superset of the permission needed here.
          # Note that if we use secrets.GITHUB_TOKEN, the pushed commit/tag cannot trigger other workflows.
          PUSH_TOKEN: ${{ secrets.CREATE_PR_TOKEN }}
      - uses: taiki-e/create-gh-release-action@v1
        with:
          changelog: ${{ inputs.changelog }}
          title: ${{ inputs.title }}
          branch: ${{ inputs.branch }}
          prefix: ${{ inputs.prefix }}
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: refs/tags/${{ needs.prepare.outputs.tag }}
      - uses: rust-lang/crates-io-auth-action@v1
        id: auth
        if: needs.prepare.outputs.has-tags == 'true'
      - name: Publish crates
        run: |
          IFS=$'\n\t'
          trap -- 's=$?; printf >&2 "%s\n" "${0##*/}:${LINENO}: \`${BASH_COMMAND}\` exit with ${s}"; exit ${s}' ERR
          args=()
          [[ -z "${INPUT_TARGET}" ]] || args+=(--target "${INPUT_TARGET}")
          if [[ -n "${INPUT_ARGS}" ]]; then
            while read -rd' '; do
              [[ -z "${REPLY}" ]] || args+=("${REPLY}")
            done <<<"${INPUT_ARGS//[$'\r\n\t']/ } " # Normalize whitespace characters into space.
          fi
          crates=()
          while read -rd,; do
            crates+=("${REPLY}")
          done <<<"${INPUT_CRATES}"
          for i in "${!crates[@]}"; do
            (
              set -x
              cd -- "${crates[${i}]}"
              # TODO: retry on failure
              # TODO: handle already published case: https://github.com/rust-lang/cargo/blob/0.80.0/publish.py#L35
              # TODO: use workspace publishing: https://blog.rust-lang.org/2025/09/18/Rust-1.90.0/#cargo-adds-native-support-for-workspace-publishing
              cargo publish "${args[@]}"
            )
            if [[ $((i + 1)) != "${#crates[@]}" ]]; then
              sleep 45 # cargo's waiting is sometimes not enough
            fi
          done
        env:
          CARGO_REGISTRY_TOKEN: ${{ needs.prepare.outputs.has-tags == 'true' && steps.auth.outputs.token || secrets.CARGO_REGISTRY_TOKEN }}
          INPUT_ARGS: ${{ inputs.args }}
          INPUT_CRATES: ${{ needs.prepare.outputs.crates }}
          INPUT_TARGET: ${{ inputs.target }}
    outputs:
      rev: ${{ steps.push.outputs.rev }}
