# Run MSRV (minimum supported Rust version) check in a pedantic, time-consuming but highly accurate way.
#
# There is no stability guarantee for this workflow, since it's supposed to only be
# used in infra managed by us.
#
# Usage:
#
# ```yml
#   msrv:
#     uses: taiki-e/github-actions/.github/workflows/msrv.yml@main
# ```
#
# See "on.workflow_call.inputs" below for input options.

permissions:
  contents: read

on:
  workflow_call:
    inputs:
      target:
        required: false
        type: string
      args:
        required: false
        type: string
      all-features:
        required: false
        type: boolean
        default: true

env:
  CARGO_INCREMENTAL: 0
  CARGO_NET_GIT_FETCH_WITH_CLI: true
  CARGO_NET_RETRY: 10
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  RUSTFLAGS: -D warnings
  RUSTDOCFLAGS: -D warnings
  RUSTUP_MAX_RETRIES: 10
  # Reusable workflows cannot inherit environment variables.
  ATOMIC_MAYBE_UNINIT_DENY_WARNINGS: 1
  CARGO_HACK_DENY_WARNINGS: 1
  CARGO_LLVM_COV_DENY_WARNINGS: 1
  CARGO_MINIMAL_VERSIONS_DENY_WARNINGS: 1
  CARGO_NO_DEV_DEPS_DENY_WARNINGS: 1
  CONST_FN_DENY_WARNINGS: 1
  PORTABLE_ATOMIC_DENY_WARNINGS: 1
  SEMIHOSTING_DENY_WARNINGS: 1

defaults:
  run:
    shell: bash --noprofile --norc -CeEuo pipefail {0}

jobs:
  prepare:
    runs-on: ubuntu-slim
    timeout-minutes: 15 # Max execution time of ubuntu-slim runner.
    steps:
      - uses: taiki-e/checkout-action@v1
      - name: Prepare
        id: prepare
        run: |
          IFS=$'\n\t'
          trap -- 's=$?; printf >&2 "%s\n" "${0##*/}:${LINENO}: \`${BASH_COMMAND}\` exit with ${s}"; exit ${s}' ERR
          normalize_comma_or_space_separated() {
            # Normalize whitespace characters into space because it's hard to handle single input contains lines with POSIX sed alone.
            local list="${1//[$'\r\n\t']/ }"
            if [[ "${list}" == *","* ]]; then
              # If a comma is contained, consider it is a comma-separated list.
              # Drop leading and trailing whitespaces in each element.
              sed -E 's/ *, */,/g; s/^.//' <<<",${list},"
            else
              # Otherwise, consider it is a whitespace-separated list.
              # Convert whitespace characters into comma.
              sed -E 's/ +/,/g; s/^.//' <<<" ${list} "
            fi
          }
          # Handle target inputs.
          linux_target=''
          apple_target=''
          windows_target=''
          if [[ -z "${INPUT_TARGET}" ]]; then
            INPUT_TARGET=x86_64-unknown-linux-gnu,aarch64-apple-darwin,x86_64-pc-windows-msvc
            # shellcheck disable=SC2046
            lowest_msrv=$(grep -E '^rust-version *=' $(git ls-files '*Cargo.toml') | sed -E 's/^[^"]+"//g; s/".*//g' | LC_ALL=C sort -Vu | head -1)
            case "${lowest_msrv}" in
              # macOS cannot be included by default since cannot be compiled on pre-1.54:
              # https://github.com/rust-lang/rust/issues/105167
              1.? | 1.[1-4]? | 1.5[0-3]) INPUT_TARGET="${INPUT_TARGET//,aarch64-apple-darwin/}" ;;
            esac
          fi
          while read -rd,; do
            case "${REPLY}" in
              *-apple-*) apple_target+=" --target ${REPLY}" ;;
              *-windows*) windows_target+=" --target ${REPLY}" ;;
              *) linux_target+=" --target ${REPLY}" ;;
            esac
          done < <(normalize_comma_or_space_separated "${INPUT_TARGET}")
          matrix=''
          [[ -z "${linux_target}" ]] || matrix+=',"ubuntu-latest"'
          [[ -z "${apple_target}" ]] || matrix+=',"macos-latest"'
          [[ -z "${windows_target}" ]] || matrix+=',"windows-latest"'
          printf '%s\n' "linux-target=${linux_target# }" >>"${GITHUB_OUTPUT}"
          printf '%s\n' "apple-target=${apple_target# }" >>"${GITHUB_OUTPUT}"
          printf '%s\n' "windows-target=${windows_target# }" >>"${GITHUB_OUTPUT}"
          printf '%s\n' "matrix={\"os\":[${matrix#,}]}" >>"${GITHUB_OUTPUT}"
        env:
          INPUT_TARGET: ${{ inputs.target }}
    outputs:
      matrix: ${{ steps.prepare.outputs.matrix }}
      linux-target: ${{ steps.prepare.outputs.linux-target }}
      apple-target: ${{ steps.prepare.outputs.apple-target }}
      windows-target: ${{ steps.prepare.outputs.windows-target }}

  build:
    needs: prepare
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.prepare.outputs.matrix) }}
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    steps:
      - uses: taiki-e/checkout-action@v1
      - uses: taiki-e/github-actions/free-device-space@main
      - uses: taiki-e/install-action@v2
        with:
          tool: cargo-hack
      - run: |
          printf 'ALL_FEATURES=--all-features\n' >>"${GITHUB_ENV}"
        if: inputs.all-features && !contains(inputs.args, '--features') && !contains(inputs.args, '--no-default-features')
      # Make sure this crate can be built with MSRV and all later versions.
      # However, this takes time, so for PR, set the version interval.
      - run: |
          IFS=$'\n\t'
          trap -- 's=$?; printf >&2 "%s\n" "${0##*/}:${LINENO}: \`${BASH_COMMAND}\` exit with ${s}"; exit ${s}' ERR
          args=()
          if [[ "${{ github.event_name }}" == 'pull_request' ]]; then
            args+=(--version-step 2)
          fi
          case "${OS}" in
            ubuntu-*) target="${LINUX_TARGET}" ;;
            macos-*) target="${APPLE_TARGET}" ;;
            windows-*) target="${WINDOWS_TARGET}" ;;
            *) exit 1 ;;
          esac
          if [[ -n "${target}" ]]; then
            while read -rd' '; do
              [[ -z "${REPLY}" ]] || args+=("${REPLY}")
            done <<<"${target} "
          fi
          if [[ -n "${INPUT_ARGS}" ]]; then
            while read -rd' '; do
              [[ -z "${REPLY}" ]] || args+=("${REPLY}")
            done <<<"${INPUT_ARGS//[$'\r\n\t']/ } " # Normalize whitespace characters into space.
          fi
          (
            set -x
            cargo hack build --workspace --no-private --no-dev-deps --version-range .. ${ALL_FEATURES:-} "${args[@]}"
          )
        env:
          INPUT_ARGS: ${{ inputs.args }}
          OS: ${{ matrix.os }}
          LINUX_TARGET: ${{ needs.prepare.outputs.linux-target }}
          APPLE_TARGET: ${{ needs.prepare.outputs.apple-target }}
          WINDOWS_TARGET: ${{ needs.prepare.outputs.windows-target }}
